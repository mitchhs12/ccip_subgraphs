# the router contract can have multiple offRamps
type OffRamp @entity {
  id: Bytes! # address - offRamp
  name: String! # name of the offRamp
  sourceChainSelector: BigInt! # uint64
  isActive: Boolean! # is the offRamp active?
  supportedTokens: [Bytes!] # array of addresses of destination tokens
  typeAndVersion: String! # type and version of the offRamp
  blockNumberLastUpdated: BigInt!
  blockTimestampLastUpdated: BigInt!
  transactionHashLastUpdated: Bytes!
  Messages: [Message!] @derivedFrom(field: "offRamp") # messages that have been sent from the offRamp
}

# the router contract must always only have one onRamp (EVM2EVM onRamp contract) - Doesn't have a name since it can be any EVM onRamp
type OnRamp @entity {
  id: Bytes! # address - onRamp
  destChainSelector: BigInt! # uint64
  typeAndVersion: String! # type and version of the onRamp
  blockNumberLastUpdated: BigInt!
  blockTimestampLastUpdated: BigInt!
  transactionHashLastUpdated: Bytes!
}

type Message @entity(immutable: true) {
  id: Bytes! # messageId - bytes32
  offRamp: OffRamp! # offRamp (where the message came from)
  calldataHash: Bytes! # bytes32
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}
