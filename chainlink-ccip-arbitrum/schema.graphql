type Message @entity(immutable: true) {
  id: Bytes! # messageId - bytes32
  offRampName: String! # name of the offRamp (where the message came from)
  sourceChainSelector: BigInt! # uint64 (the chainId of the offRamp)
  offRampAddress: Bytes! # address (the address of the arbitrum offRamp contract)
  calldataHash: Bytes! # bytes32
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

# the router contract can have multiple offRamps
type OffRamp @entity {
  id: Bytes! # address - offRamp
  name: String! # name of the offRamp
  isActive: Boolean! # is the offRamp active?
  sourceChainSelector: BigInt! # uint64
  supportedTokens: [Bytes!]! # array of addresses of destination tokens
  typeAndVersion: String! # type and version of the offRamp
  blockNumberLastUpdated: BigInt!
  blockTimestampLastUpdated: BigInt!
  transactionHashLastUpdated: Bytes!
}

# the router contract can only have one onRamp (EVM2EVM onRamp contract) - Doesn't have a name since it can be any network
type OnRamp @entity(immutable: true) {
  id: Bytes! # address - onRamp
  destChainSelector: BigInt! # uint64
  typeAndVersion: String! # type and version of the onRamp
  blockNumberLastUpdated: BigInt!
  blockTimestampLastUpdated: BigInt!
  transactionHashLastUpdated: Bytes!
}
